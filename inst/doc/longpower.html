<!DOCTYPE html>

<html>

<head>

<meta charset="utf-8" />
<meta name="generator" content="pandoc" />
<meta http-equiv="X-UA-Compatible" content="IE=EDGE" />

<meta name="viewport" content="width=device-width, initial-scale=1" />



<title>Power calculations for longitudinal data</title>



<style type="text/css">code{white-space: pre;}</style>
<style type="text/css" data-origin="pandoc">
a.sourceLine { display: inline-block; line-height: 1.25; }
a.sourceLine { pointer-events: none; color: inherit; text-decoration: inherit; }
a.sourceLine:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode { white-space: pre; position: relative; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
code.sourceCode { white-space: pre-wrap; }
a.sourceLine { text-indent: -1em; padding-left: 1em; }
}
pre.numberSource a.sourceLine
  { position: relative; left: -4em; }
pre.numberSource a.sourceLine::before
  { content: attr(title);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; pointer-events: all; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
    color: #aaaaaa;
  }
pre.numberSource { margin-left: 3em; border-left: 1px solid #aaaaaa;  padding-left: 4px; }
div.sourceCode
  {  }
@media screen {
a.sourceLine::before { text-decoration: underline; }
}
code span.al { color: #ff0000; font-weight: bold; } /* Alert */
code span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
code span.at { color: #7d9029; } /* Attribute */
code span.bn { color: #40a070; } /* BaseN */
code span.bu { } /* BuiltIn */
code span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
code span.ch { color: #4070a0; } /* Char */
code span.cn { color: #880000; } /* Constant */
code span.co { color: #60a0b0; font-style: italic; } /* Comment */
code span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
code span.do { color: #ba2121; font-style: italic; } /* Documentation */
code span.dt { color: #902000; } /* DataType */
code span.dv { color: #40a070; } /* DecVal */
code span.er { color: #ff0000; font-weight: bold; } /* Error */
code span.ex { } /* Extension */
code span.fl { color: #40a070; } /* Float */
code span.fu { color: #06287e; } /* Function */
code span.im { } /* Import */
code span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
code span.kw { color: #007020; font-weight: bold; } /* Keyword */
code span.op { color: #666666; } /* Operator */
code span.ot { color: #007020; } /* Other */
code span.pp { color: #bc7a00; } /* Preprocessor */
code span.sc { color: #4070a0; } /* SpecialChar */
code span.ss { color: #bb6688; } /* SpecialString */
code span.st { color: #4070a0; } /* String */
code span.va { color: #19177c; } /* Variable */
code span.vs { color: #4070a0; } /* VerbatimString */
code span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */

</style>
<script>
// apply pandoc div.sourceCode style to pre.sourceCode instead
(function() {
  var sheets = document.styleSheets;
  for (var i = 0; i < sheets.length; i++) {
    if (sheets[i].ownerNode.dataset["origin"] !== "pandoc") continue;
    try { var rules = sheets[i].cssRules; } catch (e) { continue; }
    for (var j = 0; j < rules.length; j++) {
      var rule = rules[j];
      // check if there is a div.sourceCode rule
      if (rule.type !== rule.STYLE_RULE || rule.selectorText !== "div.sourceCode") continue;
      var style = rule.style.cssText;
      // check if color or background-color is set
      if (rule.style.color === '' && rule.style.backgroundColor === '') continue;
      // replace div.sourceCode by a pre.sourceCode rule
      sheets[i].deleteRule(j);
      sheets[i].insertRule('pre.sourceCode{' + style + '}', j);
    }
  }
})();
</script>



<style type="text/css">body {
background-color: #fff;
margin: 1em auto;
max-width: 700px;
overflow: visible;
padding-left: 2em;
padding-right: 2em;
font-family: "Open Sans", "Helvetica Neue", Helvetica, Arial, sans-serif;
font-size: 14px;
line-height: 1.35;
}
#TOC {
clear: both;
margin: 0 0 10px 10px;
padding: 4px;
width: 400px;
border: 1px solid #CCCCCC;
border-radius: 5px;
background-color: #f6f6f6;
font-size: 13px;
line-height: 1.3;
}
#TOC .toctitle {
font-weight: bold;
font-size: 15px;
margin-left: 5px;
}
#TOC ul {
padding-left: 40px;
margin-left: -1.5em;
margin-top: 5px;
margin-bottom: 5px;
}
#TOC ul ul {
margin-left: -2em;
}
#TOC li {
line-height: 16px;
}
table {
margin: 1em auto;
border-width: 1px;
border-color: #DDDDDD;
border-style: outset;
border-collapse: collapse;
}
table th {
border-width: 2px;
padding: 5px;
border-style: inset;
}
table td {
border-width: 1px;
border-style: inset;
line-height: 18px;
padding: 5px 5px;
}
table, table th, table td {
border-left-style: none;
border-right-style: none;
}
table thead, table tr.even {
background-color: #f7f7f7;
}
p {
margin: 0.5em 0;
}
blockquote {
background-color: #f6f6f6;
padding: 0.25em 0.75em;
}
hr {
border-style: solid;
border: none;
border-top: 1px solid #777;
margin: 28px 0;
}
dl {
margin-left: 0;
}
dl dd {
margin-bottom: 13px;
margin-left: 13px;
}
dl dt {
font-weight: bold;
}
ul {
margin-top: 0;
}
ul li {
list-style: circle outside;
}
ul ul {
margin-bottom: 0;
}
pre, code {
background-color: #f7f7f7;
border-radius: 3px;
color: #333;
white-space: pre-wrap; 
}
pre {
border-radius: 3px;
margin: 5px 0px 10px 0px;
padding: 10px;
}
pre:not([class]) {
background-color: #f7f7f7;
}
code {
font-family: Consolas, Monaco, 'Courier New', monospace;
font-size: 85%;
}
p > code, li > code {
padding: 2px 0px;
}
div.figure {
text-align: center;
}
img {
background-color: #FFFFFF;
padding: 2px;
border: 1px solid #DDDDDD;
border-radius: 3px;
border: 1px solid #CCCCCC;
margin: 0 5px;
}
h1 {
margin-top: 0;
font-size: 35px;
line-height: 40px;
}
h2 {
border-bottom: 4px solid #f7f7f7;
padding-top: 10px;
padding-bottom: 2px;
font-size: 145%;
}
h3 {
border-bottom: 2px solid #f7f7f7;
padding-top: 10px;
font-size: 120%;
}
h4 {
border-bottom: 1px solid #f7f7f7;
margin-left: 8px;
font-size: 105%;
}
h5, h6 {
border-bottom: 1px solid #ccc;
font-size: 105%;
}
a {
color: #0033dd;
text-decoration: none;
}
a:hover {
color: #6666ff; }
a:visited {
color: #800080; }
a:visited:hover {
color: #BB00BB; }
a[href^="http:"] {
text-decoration: underline; }
a[href^="https:"] {
text-decoration: underline; }

code > span.kw { color: #555; font-weight: bold; } 
code > span.dt { color: #902000; } 
code > span.dv { color: #40a070; } 
code > span.bn { color: #d14; } 
code > span.fl { color: #d14; } 
code > span.ch { color: #d14; } 
code > span.st { color: #d14; } 
code > span.co { color: #888888; font-style: italic; } 
code > span.ot { color: #007020; } 
code > span.al { color: #ff0000; font-weight: bold; } 
code > span.fu { color: #900; font-weight: bold; } 
code > span.er { color: #a61717; background-color: #e3d2d2; } 
</style>




</head>

<body>




<h1 class="title toc-ignore">Power calculations for longitudinal data</h1>





<div id="introduction" class="section level1">
<h1>Introduction</h1>
<p>We will discuss power and sample size estimation for randomized placebo controlled studies in which the primary inference is based on the interaction of treatment and time in a linear mixed effects model <span class="citation">(Laird and Ware 1982)</span>. We will demonstrate how the sample size formulas of <span class="citation">Liu and Liang (1997)</span> for marginal or model fit by generalized estimating equation (GEE) <span class="citation">(Zeger and Liang 1986)</span> can be adapted for mixed effects models. Finally, using mixed effects model estimates based on data from the Alzheimer’s Disease Neuroimaging Initiative (ADNI), we will give examples of sample size calculations for models with and without baseline covariates which may help explain heterogeneity in cognitive decline and improve power.</p>
</div>
<div id="power-calculations" class="section level1">
<h1>Power calculations</h1>
<div id="exchangeable-correlation-and-random-intercept-models" class="section level2">
<h2>Exchangeable correlation and random intercept models</h2>
<p>Suppose we wish to estimate the required sample size for inference regarding the interaction of treatment and time in a longitudinal, placebo controlled study. Such calculations are relatively straightforward when the inference is based on a GEE model in which the correlation structure is assumed to be “exchangeable.” An exchangeable correlation structure specifies that all observations from within the same cluster, or repeated measures on the same subject, are equally correlated. This is exactly equivalent to a random effects model which includes a random intercept for each cluster of correlated observations. Sample sizes for study designs using these models can be calculated using a simple formula such as that in <span class="citation">(Diggle, Liang, and Zeger 1994)</span>, page 29. The formula requires the number visits, the interval between visits, the estimated model variance (<span class="math inline">\(\sigma^2\)</span>), the within subject correlation (<span class="math inline">\(\rho\)</span>), and of course the usual sample size calculation inputs (power, significance level, and effect size).</p>
<p>To translate the formula of  to the random effects setting, let us first consider the details of the assumed error structure of the GEE framework. The GEE model assumes that the response for subject <span class="math inline">\(i\)</span> at time <span class="math inline">\(t_{ij}\)</span>, denoted <span class="math inline">\(Y_{ij}\)</span>, is the group mean, dependent on time and treatment, plus an error term <span class="math inline">\(\varepsilon_{ij}\)</span>. Or, borrowing notation from , for group A: <span class="math display">\[
Y_{ij} = \beta_{0A} + \beta_{1A}t_{ij} + \varepsilon_{ij},\quad i=1,\ldots,m; j=1,\ldots,n.
\]</span> and similarly for Group B. The null hypothesis is <span class="math inline">\(H_0: d=\beta_{1A} - \beta_{1B} = 0\)</span>. Under an exchangeable correlation structure <span class="math inline">\(\mathrm{var}(Y_{ij})=\mathrm{var}(\varepsilon_{ij})=\sigma^2\)</span> and <span class="math inline">\(\mathrm{corr}(Y_{ij},Y_{ik})=\mathrm{corr}(\varepsilon_{ij}, \varepsilon_{ik})=\rho\)</span>, for all subjects, <span class="math inline">\(i\)</span>, and time points <span class="math inline">\(j, k\)</span>.</p>
<p>In the mixed effects framework we can assume a random intercept model which is equivalent to the GEE model with exchangeable correlation structure. In this case we believe <span class="math inline">\(\varepsilon_{ij} = \alpha_i + \varepsilon_{ij}^*\)</span>, where <span class="math inline">\(\alpha_i\)</span> is the random intercept term shared by all observations and <span class="math inline">\(\varepsilon_{ij}^*\)</span> are independent and identically distributed (iid) error terms. We see that <span class="math inline">\(\mathrm{var}(Y_{ij})=\mathrm{var}(\varepsilon_{ij})=\mathrm{var}(\alpha_i) + \mathrm{var}(\varepsilon_{ij}^*)\)</span> and <span class="math inline">\(\mathrm{corr}(Y_{ij},Y_{ik})=E[(\alpha_i + \varepsilon_{ij}^*)(\alpha_i + \varepsilon_{ik}^*)]/\sigma^2=\mathrm{var}(\alpha_i)/\sigma^2\)</span>. The variance of the random intercept, <span class="math inline">\(\mathrm{var}(\alpha_i)\)</span>, and the residual variance, <span class="math inline">\(\mathrm{var}(\varepsilon_{ij})\)</span>, are easily obtainable from the output of mixed effects fitting software so that one might fit a random effects model to pilot data to educate a power calculation using the GEE formula of . Assuming equal numbers in the placebo and active groups, a common visit schedule for all subjects (<span class="math inline">\(t_{ij} = t_{kj}\)</span> for all <span class="math inline">\(i,j,k\)</span>), and a random intercept model; the number of subjects per group is: <span class="math display">\[
m = \frac{2(z_\alpha + z_Q)^2(\mathrm{var}(\alpha_i) + \mathrm{var}(\varepsilon_{ij}^*))^2(1-\mathrm{var}(\alpha_i)/\sigma^2)}{ns_x^2d^2}
\]</span> where <span class="math inline">\(z_p\)</span> is the <span class="math inline">\(p\)</span>th standard normal quantile, <span class="math inline">\(Q\)</span> is <span class="math inline">\(1-P\)</span>, <span class="math inline">\(P\)</span> is the specified power, and <span class="math inline">\(s_x^2=n^{-1}\sum_j(t_{j}-\bar x)^2\)</span>. ## General correlation and random slope models</p>
<p>The random intercept model is not equipped to handle variations in the rate of change from subject to subject. In many diseases, such as Alzheimer’s disease, the rate of improvement or decline will vary greatly within the treatment group, regardless of treatment. This variation can be modeled with a random slope term. That is, we assume: <span class="math display">\[
Y_{ij} = \beta_{0A} + \beta_{1A}t_{ij} + \alpha_{0i} + \alpha_{1i}t_{ij} + \varepsilon_{ij}^*,
\]</span> where we use <span class="math inline">\(\varepsilon_{ij}^*\)</span> again to denote iid error and reserve <span class="math inline">\(\varepsilon_{ij}\)</span> for possibly correlated error. If we derive the correlation structure of <span class="math inline">\(\varepsilon_{ij}=\alpha_{0i} + \alpha_{1i}t_{ij} + \varepsilon_{ij}^*\)</span>, which is necessary in order to use GEE-based sample size formulas, we find that we no longer have an exchangeable correlation structure. In fact <span class="math inline">\(\mathrm{var}(Y_{ij})=\mathrm{var}(\varepsilon_{ij})=\mathrm{var}(\alpha_{0i})+t_{ij}^2\mathrm{var}(\alpha_{1i}) + 2t_{ij}\mathrm{cov}(\alpha_{0i},\alpha_{1i}) +\mathrm{var}(\varepsilon_{ij}^*)\)</span> and <span class="math inline">\(\mathrm{cov}(Y_{ij},Y_{ik})=\mathrm{cov}(\varepsilon_{ij},\varepsilon_{ik})=\mathrm{var}(\alpha_{0i})+t_{ij}t_{ik}\mathrm{var}(\alpha_{1i}) + (t_{ij}+t_{ik})\mathrm{cov}(\alpha_{0i},\alpha_{1i})\)</span>. For the common visit schedule case, the covariance matrix for the vector of correlated errors, <span class="math inline">\(\mathbf{\varepsilon_i}=(\varepsilon_{i1},\ldots,\varepsilon_{in})&#39;\)</span>, is of the form: <span class="math display">\[
\Sigma = [(\mathrm{var}(\alpha_{0})+t_{j}t_{k}\mathrm{var}(\alpha_{1}) + (t_{j}+t_{k})\mathrm{cov}(\alpha_{0},\alpha_{1}))]_{jk}+{\rm diag}(\mathrm{var}(\varepsilon^*_j))
\]</span> With this specification of the covariance matrix, one can use the sample size formula of  for linear GEE models (page 941). (Warning: The formula given on the bottom page 29 of  for general correlation matrices, <span class="math inline">\(R\)</span>, is wrong).</p>
<p>The formula for linear models provided by  is useful for testing <span class="math inline">\(H_0: \mathbf{\psi=0}\)</span> for any linear model of the form: <span class="math display">\[
Y_{ij} = \mathbf{x}_{ij}&#39;\mathbf{\psi} + \mathbf{z}_{ij}&#39;\mathbf{\lambda} + \varepsilon_{ij}
\]</span> where <span class="math inline">\(\mathbf{\varepsilon_i}\sim N(\mathbf{0},\sigma^2R)\)</span> and the covariates for individual <span class="math inline">\(i\)</span>, <span class="math inline">\(\mathbf{x}_{i}=(\mathbf{x}_{i1}&#39;, \ldots, \mathbf{x}_{i1}&#39;)&#39;_{n\times p}\)</span> and <span class="math inline">\(\mathbf{z}_{i}=(\mathbf{z}_{i1}&#39;, \ldots, \mathbf{z}_{i1}&#39;)&#39;_{n\times q}\)</span>, arise from a known discrete distribution. For our placebo controlled longitudinal study, the fully specified model is of the form: <span class="math display">\[
Y_{ij}=\beta_0 + \beta_1\{{\rm Group}_{i}=A\} + \beta_2t_{ij} + \beta_3t_{ij}\{{\rm Group}_{i}=A\}.
\]</span> That is, the parameter of interest for the interaction of treatment and time is <span class="math inline">\(\psi = \beta_3\)</span> and nuisance parameter is <span class="math inline">\(\mathbf{\lambda} = (\beta_0,\beta_1,\beta_2)&#39;\)</span>. The covariates are distributed as <span class="math inline">\(\mathbf{x}_{i} = \mathbf{t}= (t_1, \ldots, t_n)&#39;\)</span> and <span class="math inline">\(\mathbf{z}_j = [\mathbf{1}\, \mathbf{1}\, \mathbf{t}]_{n\times3}\)</span> with probability 1/2 (Group A); and <span class="math inline">\(\mathbf{x}_{i} = \mathbf{0}\)</span> and <span class="math inline">\(\mathbf{z}_j = [\mathbf{1}\, \mathbf{0}\, \mathbf{t}]_{n\times3}\)</span> with probability 1/2 (Group B).</p>
<p>The Liu and Liang’s formula for linear models can be coded In R as:</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb1-1" title="1"><span class="kw">library</span>(longpower)</a></code></pre></div>
<div class="sourceCode" id="cb2"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb2-1" title="1">liu.liang.linear.power</a></code></pre></div>
<pre><code>function (N = NULL, delta = NULL, u = NULL, v = NULL, sigma2 = 1, 
    R = NULL, R.list = NULL, sig.level = 0.05, power = NULL, 
    Pi = rep(1/length(u), length(u)), alternative = c(&quot;two.sided&quot;, 
        &quot;one.sided&quot;), tol = .Machine$double.eps^2) 
{
    if (sum(sapply(list(N, delta, sigma2, power, sig.level), 
        is.null)) != 1) 
        stop(&quot;exactly one of &#39;N&#39;, &#39;sigma2&#39;, &#39;delta&#39;, &#39;power&#39;, and &#39;sig.level&#39; must be NULL&quot;)
    if (!is.null(sig.level) &amp;&amp; !is.numeric(sig.level) || any(0 &gt; 
        sig.level | sig.level &gt; 1)) 
        stop(&quot;&#39;sig.level&#39; must be numeric in [0, 1]&quot;)
    alternative &lt;- match.arg(alternative)
    if (sum(c(!is.null(R), !is.null(R.list))) != 1) 
        stop(&quot;Exactly one of R or R.list must be specified.&quot;)
    if (sum(Pi) != 1) 
        stop(&quot;Pi must sum to 1.&quot;)
    if (!is.null(R)) {
        R.list &lt;- lapply(1:length(u), function(i) R)
    }
    Rinv &lt;- lapply(1:length(R.list), function(i) {
        R &lt;- R.list[[i]]
        if (is.null(dim(R)) &amp; length(R) == 1 &amp; length(u[[i]]) &gt; 
            1) {
            R &lt;- matrix(R, length(u[[i]]), length(u[[i]])) + 
                diag(1 - R, length(u[[i]]))
        }
        else if (is.null(dim(R)) &amp; length(R) == 1 &amp; length(u[[i]]) == 
            1) {
            R &lt;- matrix(R, length(u[[i]]), length(u[[i]]))
        }
        return(solve(R))
    })
    n.body &lt;- quote({
        Ipl &lt;- 0
        for (i in 1:length(u)) Ipl &lt;- Ipl + Pi[i] * t(u[[i]]) %*% 
            Rinv[[i]] %*% v[[i]]
        Ipl &lt;- Ipl/sigma2
        Ill &lt;- 0
        for (i in 1:length(u)) Ill &lt;- Ill + Pi[i] * t(v[[i]]) %*% 
            Rinv[[i]] %*% v[[i]]
        Illinv &lt;- solve(Ill/sigma2)
        Sigma1 &lt;- 0
        for (i in 1:length(u)) Sigma1 &lt;- Sigma1 + Pi[i] * (t(u[[i]]) - 
            Ipl %*% Illinv %*% t(v[[i]])) %*% Rinv[[i]] %*% (u[[i]] - 
            v[[i]] %*% Illinv %*% t(Ipl))
        Sigma1 &lt;- Sigma1/sigma2
        (qnorm(1 - ifelse(alternative == &quot;two.sided&quot;, sig.level/2, 
            sig.level)) + qnorm(power))^2/(delta %*% Sigma1 %*% 
            delta)[1, 1]
    })
    if (is.null(N)) 
        N &lt;- eval(n.body)
    else if (is.null(sig.level)) 
        sig.level &lt;- uniroot(function(sig.level) eval(n.body) - 
            N, c(1e-10, 1 - 1e-10), tol = tol, extendInt = &quot;yes&quot;)$root
    else if (is.null(power)) 
        power &lt;- uniroot(function(power) eval(n.body) - N, c(0.001, 
            1 - 1e-10), tol = tol, extendInt = &quot;yes&quot;)$root
    else if (is.null(delta)) 
        delta &lt;- uniroot(function(delta) eval(n.body) - N, sqrt(sigma2) * 
            c(1e-07, 1e+07), tol = tol, extendInt = &quot;downX&quot;)$root
    else if (is.null(sigma2)) 
        sigma2 &lt;- uniroot(function(sigma2) eval(n.body) - N, 
            delta * c(1e-07, 1e+07), tol = tol, extendInt = &quot;yes&quot;)$root
    else stop(&quot;internal error&quot;, domain = NA)
    METHOD &lt;- &quot;Longitudinal linear model power calculation (Liu &amp; Liang, 1997)&quot;
    structure(list(N = N, n = N * Pi, delta = delta, sigma2 = sigma2, 
        sig.level = sig.level, power = power, alternative = alternative, 
        R = R, note = &quot;N is *total* sample size and n is sample size in *each* group&quot;, 
        method = METHOD), class = &quot;power.longtest&quot;)
}
&lt;bytecode: 0x7feada74d848&gt;
&lt;environment: namespace:longpower&gt;</code></pre>
<p>The parameters include , the effect size (possibly vector); , the list of covariate vectors or matrices associated with the parameter of interest; , the respective list of covariate vectors or matrices associated with the nuisance parameter; , the error variance; , the correlation structure; and  the proportion of covariates of each type (, , and  are expected to be the same length and sorted with respect to each other).</p>
<p>For example, we can reproduce the table of sample sizes (per group) on page 29 of  for the given exchangeable correlations with <span class="math inline">\(\mathbf{t} = (0,2,5)&#39;\)</span>, <span class="math inline">\(\alpha=0.05\)</span>, power=0.80, and <span class="math inline">\(d=0.5\)</span> via the  function:</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb4-1" title="1">n =<span class="st"> </span><span class="dv">3</span> <span class="co"># visits</span></a>
<a class="sourceLine" id="cb4-2" title="2">t =<span class="st"> </span><span class="kw">c</span>(<span class="dv">0</span>,<span class="dv">2</span>,<span class="dv">5</span>)</a>
<a class="sourceLine" id="cb4-3" title="3">rho =<span class="st"> </span><span class="kw">c</span>(<span class="fl">0.2</span>, <span class="fl">0.5</span>, <span class="fl">0.8</span>)</a>
<a class="sourceLine" id="cb4-4" title="4">sigma2 =<span class="st"> </span><span class="kw">c</span>(<span class="dv">100</span>, <span class="dv">200</span>, <span class="dv">300</span>)</a>
<a class="sourceLine" id="cb4-5" title="5">tab.diggle =<span class="st"> </span><span class="kw">outer</span>(rho, sigma2, </a>
<a class="sourceLine" id="cb4-6" title="6">      <span class="kw">Vectorize</span>(<span class="cf">function</span>(rho, sigma2){</a>
<a class="sourceLine" id="cb4-7" title="7">        <span class="kw">ceiling</span>(<span class="kw">diggle.linear.power</span>(</a>
<a class="sourceLine" id="cb4-8" title="8">          <span class="dt">d=</span><span class="fl">0.5</span>,</a>
<a class="sourceLine" id="cb4-9" title="9">          <span class="dt">t=</span>t,</a>
<a class="sourceLine" id="cb4-10" title="10">          <span class="dt">sigma2=</span>sigma2,</a>
<a class="sourceLine" id="cb4-11" title="11">          <span class="dt">R=</span>rho,</a>
<a class="sourceLine" id="cb4-12" title="12">          <span class="dt">alternative=</span><span class="st">&quot;one.sided&quot;</span>,</a>
<a class="sourceLine" id="cb4-13" title="13">          <span class="dt">power=</span><span class="fl">0.80</span>)<span class="op">$</span>n[<span class="dv">1</span>])}))</a>
<a class="sourceLine" id="cb4-14" title="14"><span class="kw">colnames</span>(tab.diggle) =<span class="st"> </span><span class="kw">paste</span>(<span class="st">&quot;sigma2 =&quot;</span>, sigma2)</a>
<a class="sourceLine" id="cb4-15" title="15"><span class="kw">rownames</span>(tab.diggle) =<span class="st"> </span><span class="kw">paste</span>(<span class="st">&quot;rho =&quot;</span>, rho)</a>
<a class="sourceLine" id="cb4-16" title="16">tab.diggle</a></code></pre></div>
<pre><code>          sigma2 = 100 sigma2 = 200 sigma2 = 300
rho = 0.2          313          625          938
rho = 0.5          196          391          586
rho = 0.8           79          157          235</code></pre>
<p>or via the  function:</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb6-1" title="1">u =<span class="st"> </span><span class="kw">list</span>(<span class="dt">u1 =</span> t, <span class="dt">u2 =</span> <span class="kw">rep</span>(<span class="dv">0</span>,n))</a>
<a class="sourceLine" id="cb6-2" title="2">v =<span class="st"> </span><span class="kw">list</span>(<span class="dt">v1 =</span> <span class="kw">cbind</span>(<span class="dv">1</span>,<span class="dv">1</span>,t),</a>
<a class="sourceLine" id="cb6-3" title="3">         <span class="dt">v2 =</span> <span class="kw">cbind</span>(<span class="dv">1</span>,<span class="dv">0</span>,t))         </a>
<a class="sourceLine" id="cb6-4" title="4">tab.ll =<span class="st"> </span><span class="kw">outer</span>(rho, sigma2, </a>
<a class="sourceLine" id="cb6-5" title="5">      <span class="kw">Vectorize</span>(<span class="cf">function</span>(rho, sigma2){</a>
<a class="sourceLine" id="cb6-6" title="6">        <span class="kw">ceiling</span>(<span class="kw">liu.liang.linear.power</span>(</a>
<a class="sourceLine" id="cb6-7" title="7">          <span class="dt">delta=</span><span class="fl">0.5</span>, <span class="dt">u=</span>u, <span class="dt">v=</span>v,</a>
<a class="sourceLine" id="cb6-8" title="8">          <span class="dt">sigma2=</span>sigma2,</a>
<a class="sourceLine" id="cb6-9" title="9">          <span class="dt">R=</span>rho, <span class="dt">alternative=</span><span class="st">&quot;one.sided&quot;</span>,</a>
<a class="sourceLine" id="cb6-10" title="10">          <span class="dt">power=</span><span class="fl">0.80</span>)<span class="op">$</span>n[<span class="dv">1</span>])}))</a>
<a class="sourceLine" id="cb6-11" title="11"><span class="kw">colnames</span>(tab.ll) =<span class="st"> </span><span class="kw">paste</span>(<span class="st">&quot;sigma2 =&quot;</span>, sigma2)</a>
<a class="sourceLine" id="cb6-12" title="12"><span class="kw">rownames</span>(tab.ll) =<span class="st"> </span><span class="kw">paste</span>(<span class="st">&quot;rho =&quot;</span>, rho)</a>
<a class="sourceLine" id="cb6-13" title="13">tab.ll</a></code></pre></div>
<pre><code>          sigma2 = 100 sigma2 = 200 sigma2 = 300
rho = 0.2          313          625          938
rho = 0.5          196          391          586
rho = 0.8           79          157          235</code></pre>
<p>As a second example, consider an Alzheimer’s disease trial in which assessments are taken every three months for 18 months (7 visits). We assume an smallest detectable effect size of 1.5 points on the cognitive portion of the Alzheimer’s Disease Assessment Scale (ADAS-Cog). This is a 70 point scale with great variability among sick individuals. We assume the random intercept to have a variance of 55, the random slope to have a variance of 24, and a residual variance of 10. The correlation between random slope term and random intercept term is 0.8. We can estimate the necessary sample size by first generating the correlation structure. Since <span class="math inline">\(\varepsilon = \mathrm{var}(Y_{ij})\)</span> is not constant over time in this model, we fix  and set  equal to the covariance matrix for <span class="math inline">\(\mathbf{\varepsilon_i}\)</span>:</p>
<div class="sourceCode" id="cb8"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb8-1" title="1"><span class="co"># var of random intercept</span></a>
<a class="sourceLine" id="cb8-2" title="2">sig2.i =<span class="st"> </span><span class="dv">55</span></a>
<a class="sourceLine" id="cb8-3" title="3"><span class="co"># var of random slope</span></a>
<a class="sourceLine" id="cb8-4" title="4">sig2.s =<span class="st"> </span><span class="dv">24</span></a>
<a class="sourceLine" id="cb8-5" title="5"><span class="co"># residual var</span></a>
<a class="sourceLine" id="cb8-6" title="6">sig2.e =<span class="st"> </span><span class="dv">10</span></a>
<a class="sourceLine" id="cb8-7" title="7"><span class="co"># covariance of slope and intercep</span></a>
<a class="sourceLine" id="cb8-8" title="8">cov.s.i &lt;-<span class="st"> </span><span class="fl">0.8</span><span class="op">*</span><span class="kw">sqrt</span>(sig2.i)<span class="op">*</span><span class="kw">sqrt</span>(sig2.s)</a>
<a class="sourceLine" id="cb8-9" title="9"></a>
<a class="sourceLine" id="cb8-10" title="10">cov.t &lt;-<span class="st"> </span><span class="cf">function</span>(t1, t2, sig2.i, sig2.s, cov.s.i){</a>
<a class="sourceLine" id="cb8-11" title="11">        sig2.i <span class="op">+</span><span class="st"> </span>t1<span class="op">*</span>t2<span class="op">*</span>sig2.s <span class="op">+</span><span class="st"> </span>(t1<span class="op">+</span>t2)<span class="op">*</span>cov.s.i </a>
<a class="sourceLine" id="cb8-12" title="12">}</a>
<a class="sourceLine" id="cb8-13" title="13"></a>
<a class="sourceLine" id="cb8-14" title="14">t =<span class="st"> </span><span class="kw">seq</span>(<span class="dv">0</span>,<span class="fl">1.5</span>,<span class="fl">0.25</span>)</a>
<a class="sourceLine" id="cb8-15" title="15">n =<span class="st"> </span><span class="kw">length</span>(t)</a>
<a class="sourceLine" id="cb8-16" title="16">R =<span class="st"> </span><span class="kw">outer</span>(t, t, <span class="cf">function</span>(x,y){<span class="kw">cov.t</span>(x,y, sig2.i, sig2.s, cov.s.i)})</a>
<a class="sourceLine" id="cb8-17" title="17">R =<span class="st"> </span>R <span class="op">+</span><span class="st"> </span><span class="kw">diag</span>(sig2.e, n, n)</a>
<a class="sourceLine" id="cb8-18" title="18">u =<span class="st"> </span><span class="kw">list</span>(<span class="dt">u1 =</span> t, <span class="dt">u2 =</span> <span class="kw">rep</span>(<span class="dv">0</span>,n))</a>
<a class="sourceLine" id="cb8-19" title="19">v =<span class="st"> </span><span class="kw">list</span>(<span class="dt">v1 =</span> <span class="kw">cbind</span>(<span class="dv">1</span>,<span class="dv">1</span>,t),</a>
<a class="sourceLine" id="cb8-20" title="20">         <span class="dt">v2 =</span> <span class="kw">cbind</span>(<span class="dv">1</span>,<span class="dv">0</span>,t))         </a>
<a class="sourceLine" id="cb8-21" title="21"></a>
<a class="sourceLine" id="cb8-22" title="22"><span class="kw">liu.liang.linear.power</span>(<span class="dt">d=</span><span class="fl">1.5</span>, <span class="dt">u=</span>u, <span class="dt">v=</span>v, <span class="dt">R=</span>R, <span class="dt">sig.level=</span><span class="fl">0.05</span>, <span class="dt">power=</span><span class="fl">0.80</span>)</a></code></pre></div>
<pre><code>
     Longitudinal linear model power calculation (Liu &amp; Liang, 1997) 

              N = 414.6202
              n = 207.3101, 207.3101
          delta = 1.5
         sigma2 = 1
      sig.level = 0.05
          power = 0.8
    alternative = two.sided

 NOTE: N is *total* sample size and n is sample size in *each* group 

 R:
         [,1]      [,2]      [,3]      [,4]      [,5]     [,6]      [,7]
[1,] 65.00000  62.26636  69.53272  76.79908  84.06544  91.3318  98.59817
[2,] 62.26636  81.03272  79.79908  88.56544  97.33180 106.0982 114.86453
[3,] 69.53272  79.79908 100.06544 100.33180 110.59817 120.8645 131.13089
[4,] 76.79908  88.56544 100.33180 122.09817 123.86453 135.6309 147.39725
[5,] 84.06544  97.33180 110.59817 123.86453 147.13089 150.3972 163.66361
[6,] 91.33180 106.09817 120.86453 135.63089 150.39725 175.1636 179.92997
[7,] 98.59817 114.86453 131.13089 147.39725 163.66361 179.9300 206.19633</code></pre>
<p>So the study would require about 207 subjects per arm to achieve 80% power, with a two-tailed <span class="math inline">\(\alpha=0.05\)</span>.</p>
<p>The simple formula provided in  suggests the required number of subjects can be found by <span class="math inline">\(2(z_\alpha+z_Q)^2\xi/d^2\)</span>, where <span class="math display">\[
\xi_\textrm{WRONG}=
  \left(\begin{array}{cc}
    0 &amp; 1\\ 
    \end{array}\right)
\left(\begin{array}{ccc}
1 &amp; \ldots &amp; 1 \\
t_1 &amp; \ldots &amp; t_n \\
\end{array}\right)R^{-1}
\left(\begin{array}{ccc}
1 &amp; t_1 \\
\vdots &amp; \vdots\\
1 &amp; t_n
\end{array}\right)
  \left(\begin{array}{c}
    0 \\ 1
    \end{array}\right).
\]</span> Executing this for our Alzheimer’s example, we get a sample size of:</p>
<div class="sourceCode" id="cb10"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb10-1" title="1">x =<span class="st"> </span>(<span class="kw">rbind</span>(<span class="dv">1</span>,t)<span class="op">%*%</span><span class="kw">solve</span>(R)<span class="op">%*%</span><span class="kw">cbind</span>(<span class="dv">1</span>,t))[<span class="dv">2</span>,<span class="dv">2</span>]</a>
<a class="sourceLine" id="cb10-2" title="2">x<span class="op">*</span><span class="dv">2</span><span class="op">*</span>(<span class="kw">qnorm</span>(<span class="dv">1</span><span class="fl">-0.05</span><span class="op">/</span><span class="dv">2</span>) <span class="op">+</span><span class="st"> </span><span class="kw">qnorm</span>(<span class="fl">0.80</span>))<span class="op">^</span><span class="dv">2</span><span class="op">/</span><span class="fl">1.5</span><span class="op">^</span><span class="dv">2</span></a></code></pre></div>
<pre><code>[1] 0.3592744</code></pre>
<p>which is clearly wrong. In fact, there is a typo in . The correct formula for <span class="math inline">\(\xi\)</span> is: <span class="math display">\[\begin{equation}\label{eq:diggle3}
\xi = 
  \left(\begin{array}{cc}
    0 &amp; 1\\ 
    \end{array}\right)
  \left[
  \left(\begin{array}{ccc}
    1 &amp; \cdots &amp; 1 \\
    t_1 &amp; \cdots &amp; t_2\end{array}\right)
  (\sigma^2R)^{-1}
  \left(\begin{array}{cc}
    1 &amp; t_1 \\
    \vdots &amp; \vdots \\
    1 &amp; t_m\end{array}\right)\right]^{-1}
  \left(\begin{array}{c}
    0 \\ 1
    \end{array}\right).
\end{equation}\]</span> Applying the correct formula, we get</p>
<div class="sourceCode" id="cb12"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb12-1" title="1">x =<span class="st"> </span><span class="kw">solve</span>(<span class="kw">rbind</span>(<span class="dv">1</span>,t)<span class="op">%*%</span><span class="kw">solve</span>(R)<span class="op">%*%</span><span class="kw">cbind</span>(<span class="dv">1</span>,t))[<span class="dv">2</span>,<span class="dv">2</span>]</a>
<a class="sourceLine" id="cb12-2" title="2">x<span class="op">*</span><span class="dv">2</span><span class="op">*</span>(<span class="kw">qnorm</span>(<span class="dv">1</span><span class="fl">-0.05</span><span class="op">/</span><span class="dv">2</span>) <span class="op">+</span><span class="st"> </span><span class="kw">qnorm</span>(<span class="fl">0.80</span>))<span class="op">^</span><span class="dv">2</span><span class="op">/</span><span class="fl">1.5</span><span class="op">^</span><span class="dv">2</span></a></code></pre></div>
<pre><code>[1] 207.3101</code></pre>
<p>Similarly, using , we attempt to derive the correct closed form formula for this specific linear model. The required sample size per group is given as <span class="math display">\[
m = \nu/(\psi_1&#39;\tilde\Sigma_1\psi_1)
\]</span> where <span class="math display">\[
\tilde\Sigma_1 =\sigma^{-2}\sum_{l=1}^m\pi_l
(\mathbf{u}_l&#39;-I_{\psi\lambda}I_{\lambda\lambda}^-1\mathbf{v}_l&#39;)R^{-1}
(\mathbf{u}_l&#39;-\mathbf{v}_lI_{\lambda\lambda}^-1I_{\psi\lambda}&#39;),
\]</span> <span class="math display">\[
I_{\psi\lambda}=\sigma^{-2}\sum_{i=1}^m\pi_l
\mathbf{u}_l&#39;R^{-1}\mathbf{v}_l,
\]</span> and <span class="math display">\[
I_{\lambda\lambda}=\sigma^{-2}\sum_{i=1}^m\pi_l
\mathbf{v}_l&#39;R^{-1}\mathbf{v}_l.
\]</span> Again, in our case the probability of each of the two covariate values is <span class="math inline">\(\pi_1=\pi_2=1/2\)</span>; and <span class="math inline">\(\mathbf{u}_1 = (t_1, \ldots, t_n)&#39;\)</span>, <span class="math inline">\(\mathbf{v}_1 = [\mathbf{1}\, \mathbf{0}\, \mathbf{x}_i]_{n\times3}\)</span>, <span class="math inline">\(\mathbf{u}_2 = \mathbf{0}\)</span>, and <span class="math inline">\(\mathbf{v}_2 = [\mathbf{1}\, \mathbf{0}\, \mathbf{x}_i]_{n\times3}\)</span>. We have</p>
<p><span class="math display">\[\begin{eqnarray*}
I_{\psi\lambda}&amp; = &amp; \sigma^{-2}/2\mathbf{u}_1&#39;R^{-1}\mathbf{v}_1\\
I_{\lambda\lambda}&amp; = &amp; \sigma^{-2}/2[\mathbf{v}_1&#39;R^{-1}\mathbf{v}_1 + \mathbf{v}_2&#39;R^{-1}\mathbf{v}_2]=1/2X]\\
I_{\psi\lambda}I_{\lambda\lambda}^{-1} &amp; = &amp; \mathbf{u}_1&#39;R^{-1}\mathbf{v}_1X^{-1}\\
I_{\lambda\lambda}^{-1}I_{\psi\lambda}&#39; &amp; = &amp; X^{-1}\mathbf{v}_1&#39;R^{-1}\mathbf{u}_1
\end{eqnarray*}\]</span></p>
<p><span class="math display">\[\begin{eqnarray*}
\tilde\Sigma_1 &amp; = &amp; \sigma^{-2}/2
[(\mathbf{u}_1-\mathbf{u}_1&#39;R^{-1}\mathbf{v}_1X^{-1}\mathbf{v}_1&#39;)
R^{-1}
(\mathbf{u}_1-\mathbf{v}_1X^{-1}\mathbf{v}_1&#39;R^{-1}\mathbf{u}_1)\\
&amp; &amp; +  \mathbf{u}_1&#39;R^{-1}\mathbf{v}_1X^{-1}\mathbf{v}_2&#39;R^{-1}\mathbf{v}_2X^{-1}\mathbf{v}_1R^{-1}\mathbf{u}_1\\
&amp; = &amp; 
\sigma^{-2}/2[\mathbf{u}_1R^{-1}\mathbf{u}- \mathbf{u}_1&#39;R^{-1}\mathbf{v}_1X^{-1}\mathbf{v}_1&#39;R^{-1}\mathbf{u}_1]
\end{eqnarray*}\]</span> Applying this to our working example:</p>
<div class="sourceCode" id="cb14"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb14-1" title="1">X =<span class="st"> </span><span class="kw">t</span>(v[[<span class="dv">1</span>]])<span class="op">%*%</span><span class="kw">solve</span>(R)<span class="op">%*%</span>v[[<span class="dv">1</span>]] <span class="op">+</span><span class="st"> </span></a>
<a class="sourceLine" id="cb14-2" title="2"><span class="st">    </span><span class="kw">t</span>(v[[<span class="dv">2</span>]])<span class="op">%*%</span><span class="kw">solve</span>(R)<span class="op">%*%</span>v[[<span class="dv">2</span>]]</a>
<a class="sourceLine" id="cb14-3" title="3"></a>
<a class="sourceLine" id="cb14-4" title="4">Sigma1 =<span class="st"> </span>((<span class="kw">t</span>(u[[<span class="dv">1</span>]])<span class="op">%*%</span><span class="kw">solve</span>(R)<span class="op">%*%</span>t <span class="op">-</span><span class="st"> </span></a>
<a class="sourceLine" id="cb14-5" title="5"><span class="st">           </span><span class="kw">t</span>(u[[<span class="dv">1</span>]])<span class="op">%*%</span><span class="kw">solve</span>(R)<span class="op">%*%</span>v[[<span class="dv">1</span>]]<span class="op">%*%</span><span class="kw">solve</span>(X)<span class="op">%*%</span><span class="kw">t</span>(v[[<span class="dv">1</span>]])<span class="op">%*%</span><span class="kw">solve</span>(R)<span class="op">%*%</span>t)<span class="op">/</span><span class="dv">2</span>)</a>
<a class="sourceLine" id="cb14-6" title="6"></a>
<a class="sourceLine" id="cb14-7" title="7">(<span class="kw">qnorm</span>(<span class="dv">1</span><span class="fl">-0.05</span><span class="op">/</span><span class="dv">2</span>) <span class="op">+</span><span class="st"> </span><span class="kw">qnorm</span>(<span class="fl">0.80</span>))<span class="op">^</span><span class="dv">2</span><span class="op">/</span>(Sigma1<span class="op">*</span>(<span class="fl">1.5</span>)<span class="op">^</span><span class="dv">2</span>)<span class="op">/</span><span class="dv">2</span></a></code></pre></div>
<pre><code>         [,1]
[1,] 207.3101</code></pre>
<!-- ## Example: Ophthalmology -->
<!-- Suppose we are planning a study to test the reproducibility of a non-invasive diagnostic imaging tool, spectral domain optical coherence tomography (OCT), for children with retinal pathology. OCT produces a measure of cortical thickness in the left and right eye. We consider modeling the linear association the cortical thickness as measured by the first OCT, $X$, and the second $Y$, as: -->
<!-- \[ -->
<!-- Y_{ij} = \beta_0 + \beta_1X_{ij} + \alpha_{i} + \epsilon_{ij}^* -->
<!-- \] -->
<!-- for individual $i=1,\ldots,N$, and eye $j=1,2$. The parameter of interest is $\psi=\beta_1$ and the nuisance parameter is $\beta_0$. The covariates are distributed as $\x_{i}=(1,1)'$, and $\mathbf{z}_{i}=(z_1,z_2)\sim N(\mathbf{0},\Sigma)$ -->
<!-- ```{r echo=TRUE} -->
<!-- n=2 -->
<!-- B=10000 -->
<!-- rho = 0.5 -->
<!-- Sigma = matrix(c(1,rho,rho,1),nrow=2) # variance/covariance matrix for left/right obs -->
<!-- u = v = vector("list",B) -->
<!-- for(i in 1:B) u[[i]] = rep(1,2) -->
<!-- vv = rmvnorm(B, sigma = Sigma) -->
<!-- for(i in 1:B) v[[i]] = vv[i,] -->
<!-- liu.liang.linear.power(d=0.1, u=u, v=v, R=Sigma, sig.level=0.05/2) -->
<!-- liu.liang.linear.power(d=0.25, u=u, v=v, R=Sigma, sig.level=0.05/2) -->
<!-- liu.liang.linear.power(d=0.5, u=u, v=v, R=Sigma, sig.level=0.05/2) -->
<!-- liu.liang.linear.power(d=0.75, u=u, v=v, R=Sigma, sig.level=0.05/2) -->
<!-- ``` -->
<!-- Simulated power: -->
<!-- ```{r echo=FALSE} -->
<!-- library(nlme) -->
<!-- B=10000 -->
<!-- n = 20 -->
<!-- sim = rep(0,B) -->
<!-- d = 0.5 -->
<!-- for(i in 1:B){ -->
<!-- X = rmvnorm(n, sigma = Sigma) -->
<!-- e = rmvnorm(n, sigma = Sigma) -->
<!-- X = as.vector(t(X)) -->
<!-- e = as.vector(t(e)) -->
<!-- cluster = rep(1:n,rep(2,n)) -->
<!-- Y = d*X + e -->
<!-- if(summary(lme(Y~X, random = ~ 1 | cluster))$tTable["X","p-value"]<0.05) sim[i]=1 -->
<!-- } -->
<!-- sum(sim)/B -->
<!-- ``` -->
</div>
</div>
<div id="references" class="section level1 unnumbered">
<h1>References</h1>
<div id="refs" class="references">
<div id="ref-diggle">
<p>Diggle, Peter, Kung-Yee Liang, and Scott L. Zeger. 1994. <em>Analysis of Longitudinal Data</em>. Oxford; New York: Clarendon Press ; Oxford University Press.</p>
</div>
<div id="ref-laird">
<p>Laird, N. M., and J. H. Ware. 1982. “Random-Effects Models for Longitudinal Data.” <em>Biometrics</em> 38 (4): 963–74.</p>
</div>
<div id="ref-liu">
<p>Liu, G., and K. Y. Liang. 1997. “Sample Size Calculations for Studies with Correlated Observations.” <em>Biometrics</em> 53 (3): 937–47.</p>
</div>
<div id="ref-zeger">
<p>Zeger, S. L., and K. Y. Liang. 1986. “Longitudinal Data Analysis for Discrete and Continuous Outcomes.” <em>Biometrics</em> 42 (1): 121–30.</p>
</div>
</div>
</div>



<!-- code folding -->


<!-- dynamically load mathjax for compatibility with self-contained -->
<script>
  (function () {
    var script = document.createElement("script");
    script.type = "text/javascript";
    script.src  = "https://mathjax.rstudio.com/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML";
    document.getElementsByTagName("head")[0].appendChild(script);
  })();
</script>

</body>
</html>
