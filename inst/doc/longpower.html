<!DOCTYPE html>

<html>

<head>

<meta charset="utf-8" />
<meta name="generator" content="pandoc" />
<meta http-equiv="X-UA-Compatible" content="IE=EDGE" />

<meta name="viewport" content="width=device-width, initial-scale=1" />

<meta name="author" content="Michael C. Donohue" />

<meta name="date" content="2024-08-26" />

<title>Power for linear models of longitudinal data with applications to Alzheimer’s Disease Phase II study design</title>

<script>// Pandoc 2.9 adds attributes on both header and div. We remove the former (to
// be compatible with the behavior of Pandoc < 2.8).
document.addEventListener('DOMContentLoaded', function(e) {
  var hs = document.querySelectorAll("div.section[class*='level'] > :first-child");
  var i, h, a;
  for (i = 0; i < hs.length; i++) {
    h = hs[i];
    if (!/^h[1-6]$/i.test(h.tagName)) continue;  // it should be a header h1-h6
    a = h.attributes;
    while (a.length > 0) h.removeAttribute(a[0].name);
  }
});
</script>

<style type="text/css">
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
span.underline{text-decoration: underline;}
div.column{display: inline-block; vertical-align: top; width: 50%;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
</style>



<style type="text/css">
code {
white-space: pre;
}
.sourceCode {
overflow: visible;
}
</style>
<style type="text/css" data-origin="pandoc">
pre > code.sourceCode { white-space: pre; position: relative; }
pre > code.sourceCode > span { display: inline-block; line-height: 1.25; }
pre > code.sourceCode > span:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode > span { color: inherit; text-decoration: inherit; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
pre > code.sourceCode { white-space: pre-wrap; }
pre > code.sourceCode > span { text-indent: -5em; padding-left: 5em; }
}
pre.numberSource code
{ counter-reset: source-line 0; }
pre.numberSource code > span
{ position: relative; left: -4em; counter-increment: source-line; }
pre.numberSource code > span > a:first-child::before
{ content: counter(source-line);
position: relative; left: -1em; text-align: right; vertical-align: baseline;
border: none; display: inline-block;
-webkit-touch-callout: none; -webkit-user-select: none;
-khtml-user-select: none; -moz-user-select: none;
-ms-user-select: none; user-select: none;
padding: 0 4px; width: 4em;
color: #aaaaaa;
}
pre.numberSource { margin-left: 3em; border-left: 1px solid #aaaaaa; padding-left: 4px; }
div.sourceCode
{ }
@media screen {
pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
}
code span.al { color: #ff0000; font-weight: bold; } 
code span.an { color: #60a0b0; font-weight: bold; font-style: italic; } 
code span.at { color: #7d9029; } 
code span.bn { color: #40a070; } 
code span.bu { color: #008000; } 
code span.cf { color: #007020; font-weight: bold; } 
code span.ch { color: #4070a0; } 
code span.cn { color: #880000; } 
code span.co { color: #60a0b0; font-style: italic; } 
code span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } 
code span.do { color: #ba2121; font-style: italic; } 
code span.dt { color: #902000; } 
code span.dv { color: #40a070; } 
code span.er { color: #ff0000; font-weight: bold; } 
code span.ex { } 
code span.fl { color: #40a070; } 
code span.fu { color: #06287e; } 
code span.im { color: #008000; font-weight: bold; } 
code span.in { color: #60a0b0; font-weight: bold; font-style: italic; } 
code span.kw { color: #007020; font-weight: bold; } 
code span.op { color: #666666; } 
code span.ot { color: #007020; } 
code span.pp { color: #bc7a00; } 
code span.sc { color: #4070a0; } 
code span.ss { color: #bb6688; } 
code span.st { color: #4070a0; } 
code span.va { color: #19177c; } 
code span.vs { color: #4070a0; } 
code span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } 
</style>
<script>
// apply pandoc div.sourceCode style to pre.sourceCode instead
(function() {
  var sheets = document.styleSheets;
  for (var i = 0; i < sheets.length; i++) {
    if (sheets[i].ownerNode.dataset["origin"] !== "pandoc") continue;
    try { var rules = sheets[i].cssRules; } catch (e) { continue; }
    var j = 0;
    while (j < rules.length) {
      var rule = rules[j];
      // check if there is a div.sourceCode rule
      if (rule.type !== rule.STYLE_RULE || rule.selectorText !== "div.sourceCode") {
        j++;
        continue;
      }
      var style = rule.style.cssText;
      // check if color or background-color is set
      if (rule.style.color === '' && rule.style.backgroundColor === '') {
        j++;
        continue;
      }
      // replace div.sourceCode by a pre.sourceCode rule
      sheets[i].deleteRule(j);
      sheets[i].insertRule('pre.sourceCode{' + style + '}', j);
    }
  }
})();
</script>



<style type="text/css">

div.csl-bib-body { }
div.csl-entry {
clear: both;
}
.hanging div.csl-entry {
margin-left:2em;
text-indent:-2em;
}
div.csl-left-margin {
min-width:2em;
float:left;
}
div.csl-right-inline {
margin-left:2em;
padding-left:1em;
}
div.csl-indent {
margin-left: 2em;
}
</style>

<style type="text/css">body {
background-color: #fff;
margin: 1em auto;
max-width: 700px;
overflow: visible;
padding-left: 2em;
padding-right: 2em;
font-family: "Open Sans", "Helvetica Neue", Helvetica, Arial, sans-serif;
font-size: 14px;
line-height: 1.35;
}
#TOC {
clear: both;
margin: 0 0 10px 10px;
padding: 4px;
width: 400px;
border: 1px solid #CCCCCC;
border-radius: 5px;
background-color: #f6f6f6;
font-size: 13px;
line-height: 1.3;
}
#TOC .toctitle {
font-weight: bold;
font-size: 15px;
margin-left: 5px;
}
#TOC ul {
padding-left: 40px;
margin-left: -1.5em;
margin-top: 5px;
margin-bottom: 5px;
}
#TOC ul ul {
margin-left: -2em;
}
#TOC li {
line-height: 16px;
}
table {
margin: 1em auto;
border-width: 1px;
border-color: #DDDDDD;
border-style: outset;
border-collapse: collapse;
}
table th {
border-width: 2px;
padding: 5px;
border-style: inset;
}
table td {
border-width: 1px;
border-style: inset;
line-height: 18px;
padding: 5px 5px;
}
table, table th, table td {
border-left-style: none;
border-right-style: none;
}
table thead, table tr.even {
background-color: #f7f7f7;
}
p {
margin: 0.5em 0;
}
blockquote {
background-color: #f6f6f6;
padding: 0.25em 0.75em;
}
hr {
border-style: solid;
border: none;
border-top: 1px solid #777;
margin: 28px 0;
}
dl {
margin-left: 0;
}
dl dd {
margin-bottom: 13px;
margin-left: 13px;
}
dl dt {
font-weight: bold;
}
ul {
margin-top: 0;
}
ul li {
list-style: circle outside;
}
ul ul {
margin-bottom: 0;
}
pre, code {
background-color: #f7f7f7;
border-radius: 3px;
color: #333;
white-space: pre-wrap; 
}
pre {
border-radius: 3px;
margin: 5px 0px 10px 0px;
padding: 10px;
}
pre:not([class]) {
background-color: #f7f7f7;
}
code {
font-family: Consolas, Monaco, 'Courier New', monospace;
font-size: 85%;
}
p > code, li > code {
padding: 2px 0px;
}
div.figure {
text-align: center;
}
img {
background-color: #FFFFFF;
padding: 2px;
border: 1px solid #DDDDDD;
border-radius: 3px;
border: 1px solid #CCCCCC;
margin: 0 5px;
}
h1 {
margin-top: 0;
font-size: 35px;
line-height: 40px;
}
h2 {
border-bottom: 4px solid #f7f7f7;
padding-top: 10px;
padding-bottom: 2px;
font-size: 145%;
}
h3 {
border-bottom: 2px solid #f7f7f7;
padding-top: 10px;
font-size: 120%;
}
h4 {
border-bottom: 1px solid #f7f7f7;
margin-left: 8px;
font-size: 105%;
}
h5, h6 {
border-bottom: 1px solid #ccc;
font-size: 105%;
}
a {
color: #0033dd;
text-decoration: none;
}
a:hover {
color: #6666ff; }
a:visited {
color: #800080; }
a:visited:hover {
color: #BB00BB; }
a[href^="http:"] {
text-decoration: underline; }
a[href^="https:"] {
text-decoration: underline; }

code > span.kw { color: #555; font-weight: bold; } 
code > span.dt { color: #902000; } 
code > span.dv { color: #40a070; } 
code > span.bn { color: #d14; } 
code > span.fl { color: #d14; } 
code > span.ch { color: #d14; } 
code > span.st { color: #d14; } 
code > span.co { color: #888888; font-style: italic; } 
code > span.ot { color: #007020; } 
code > span.al { color: #ff0000; font-weight: bold; } 
code > span.fu { color: #900; font-weight: bold; } 
code > span.er { color: #a61717; background-color: #e3d2d2; } 
</style>




</head>

<body>




<h1 class="title toc-ignore">Power for linear models of longitudinal
data with applications to Alzheimer’s Disease Phase II study design</h1>
<h4 class="author">Michael C. Donohue</h4>
<h4 class="date">2024-08-26</h4>



<div id="introduction" class="section level1">
<h1>Introduction</h1>
<p>We will discuss power and sample size estimation for randomized
placebo controlled studies in which the primary inference is based on
the interaction of treatment and time in a linear mixed effects model
<span class="citation">(Laird and Ware 1982)</span>. We will demonstrate
how the sample size formulas of <span class="citation">Liu and Liang
(1997)</span> for marginal or model fit by generalized estimating
equation (GEE) <span class="citation">(Zeger and Liang 1986)</span> can
be adapted for mixed effects models. Finally, using mixed effects model
estimates based on data from the Alzheimer’s Disease Neuroimaging
Initiative (ADNI), we will give examples of sample size calculations for
models with and without baseline covariates which may help explain
heterogeneity in cognitive decline and improve power.</p>
</div>
<div id="power-calculations" class="section level1">
<h1>Power calculations</h1>
<div id="exchangeable-correlation-and-random-intercept-models" class="section level2">
<h2>Exchangeable correlation and random intercept models</h2>
<p>Suppose we wish to estimate the required sample size for inference
regarding the interaction of treatment and time in a longitudinal,
placebo controlled study. Such calculations are relatively
straightforward when the inference is based on a GEE model in which the
correlation structure is assumed to be “exchangeable.” An exchangeable
correlation structure specifies that all observations from within the
same cluster, or repeated measures on the same subject, are equally
correlated. This is exactly equivalent to a random effects model which
includes a random intercept for each cluster of correlated observations.
Sample sizes for study designs using these models can be calculated
using a simple formula such as that in <span class="citation">Diggle,
Liang, and Zeger (1994)</span>, page 29. The formula requires the number
visits, the interval between visits, the estimated model variance (<span class="math inline">\(\sigma^2\)</span>), the within subject correlation
(<span class="math inline">\(\rho\)</span>), and of course the usual
sample size calculation inputs (power, significance level, and effect
size).</p>
<p>To translate the formula of <span class="citation">Diggle, Liang, and
Zeger (1994)</span> to the random effects setting, let us first consider
the details of the assumed error structure of the GEE framework. The GEE
model assumes that the response for subject <span class="math inline">\(i\)</span> at time <span class="math inline">\(t_{ij}\)</span>, denoted <span class="math inline">\(Y_{ij}\)</span>, is the group mean, dependent on
time and treatment, plus an error term <span class="math inline">\(\varepsilon_{ij}\)</span>. Or, borrowing notation
from <span class="citation">Diggle, Liang, and Zeger (1994)</span>, for
group A: <span class="math display">\[
Y_{ij} = \beta_{0A} + \beta_{1A}t_{ij} + \varepsilon_{ij},\quad
i=1,\ldots,m; j=1,\ldots,n.
\]</span> and similarly for Group B. The null hypothesis is <span class="math inline">\(H_0: d=\beta_{1A} - \beta_{1B} = 0\)</span>. Under
an exchangeable correlation structure <span class="math inline">\(\mathrm{var}(Y_{ij})=\mathrm{var}(\varepsilon_{ij})=\sigma^2\)</span>
and <span class="math inline">\(\mathrm{corr}(Y_{ij},Y_{ik})=\mathrm{corr}(\varepsilon_{ij},
\varepsilon_{ik})=\rho\)</span>, for all subjects, <span class="math inline">\(i\)</span>, and time points <span class="math inline">\(j, k\)</span>.</p>
<p>In the mixed effects framework we can assume a random intercept model
which is equivalent to the GEE model with exchangeable correlation
structure. In this case we believe <span class="math inline">\(\varepsilon_{ij} = \alpha_i +
\varepsilon_{ij}^*\)</span>, where <span class="math inline">\(\alpha_i\)</span> is the random intercept term
shared by all observations and <span class="math inline">\(\varepsilon_{ij}^*\)</span> are independent and
identically distributed (iid) error terms. We see that <span class="math inline">\(\mathrm{var}(Y_{ij})=\mathrm{var}(\varepsilon_{ij})=\mathrm{var}(\alpha_i)
+ \mathrm{var}(\varepsilon_{ij}^*)\)</span> and <span class="math inline">\(\mathrm{corr}(Y_{ij},Y_{ik})=E[(\alpha_i +
\varepsilon_{ij}^*)(\alpha_i +
\varepsilon_{ik}^*)]/\sigma^2=\mathrm{var}(\alpha_i)/\sigma^2\)</span>.
The variance of the random intercept, <span class="math inline">\(\mathrm{var}(\alpha_i)\)</span>, and the residual
variance, <span class="math inline">\(\mathrm{var}(\varepsilon_{ij})\)</span>, are
easily obtainable from the output of mixed effects fitting software so
that one might fit a random effects model to pilot data to educate a
power calculation using the GEE formula of <span class="citation">Diggle, Liang, and Zeger (1994)</span>. Assuming equal
numbers in the placebo and active groups, a common visit schedule for
all subjects (<span class="math inline">\(t_{ij} = t_{kj}\)</span> for
all <span class="math inline">\(i,j,k\)</span>), and a random intercept
model; the number of subjects per group is: <span class="math display">\[
m = \frac{2(z_\alpha + z_Q)^2(\mathrm{var}(\alpha_i) +
\mathrm{var}(\varepsilon_{ij}^*))^2(1-\mathrm{var}(\alpha_i)/\sigma^2)}{ns_x^2d^2}
\]</span> where <span class="math inline">\(z_p\)</span> is the <span class="math inline">\(p\)</span>th standard normal quantile, <span class="math inline">\(Q\)</span> is <span class="math inline">\(1-P\)</span>, <span class="math inline">\(P\)</span> is the specified power, and <span class="math inline">\(s_x^2=n^{-1}\sum_j(t_{j}-\bar x)^2\)</span>.</p>
</div>
<div id="general-correlation-and-random-slope-models" class="section level2">
<h2>General correlation and random slope models</h2>
<p>The random intercept model is not equipped to handle variations in
the rate of change from subject to subject. In many diseases, such as
Alzheimer’s disease, the rate of improvement or decline will vary
greatly within the treatment group, regardless of treatment. This
variation can be modeled with a random slope term. That is, we assume:
<span class="math display">\[
Y_{ij} = \beta_{0A} + \beta_{1A}t_{ij} + \alpha_{0i} + \alpha_{1i}t_{ij}
+ \varepsilon_{ij}^*,
\]</span> where we use <span class="math inline">\(\varepsilon_{ij}^*\)</span> again to denote iid
error and reserve <span class="math inline">\(\varepsilon_{ij}\)</span>
for possibly correlated error. If we derive the correlation structure of
<span class="math inline">\(\varepsilon_{ij}=\alpha_{0i} +
\alpha_{1i}t_{ij} + \varepsilon_{ij}^*\)</span>, which is necessary in
order to use GEE-based sample size formulas, we find that we no longer
have an exchangeable correlation structure. In fact <span class="math inline">\(\mathrm{var}(Y_{ij})=\mathrm{var}(\varepsilon_{ij})=\mathrm{var}(\alpha_{0i})+t_{ij}^2\mathrm{var}(\alpha_{1i})
+ 2t_{ij}\mathrm{cov}(\alpha_{0i},\alpha_{1i})
+\mathrm{var}(\varepsilon_{ij}^*)\)</span> and <span class="math inline">\(\mathrm{cov}(Y_{ij},Y_{ik})=\mathrm{cov}(\varepsilon_{ij},\varepsilon_{ik})=\mathrm{var}(\alpha_{0i})+t_{ij}t_{ik}\mathrm{var}(\alpha_{1i})
+ (t_{ij}+t_{ik})\mathrm{cov}(\alpha_{0i},\alpha_{1i})\)</span>. For the
common visit schedule case, the covariance matrix for the vector of
correlated errors, <span class="math inline">\(\mathbf{\varepsilon_i}=(\varepsilon_{i1},\ldots,\varepsilon_{in})&#39;\)</span>,
is of the form: <span class="math display">\[
\Sigma = [(\mathrm{var}(\alpha_{0})+t_{j}t_{k}\mathrm{var}(\alpha_{1}) +
(t_{j}+t_{k})\mathrm{cov}(\alpha_{0},\alpha_{1}))]_{jk}+{\rm
diag}(\mathrm{var}(\varepsilon^*_j))
\]</span> With this specification of the covariance matrix, one can use
the sample size formula of <span class="citation">Liu and Liang
(1997)</span> for linear GEE models (page 941). (Warning: The formula
given on the bottom page 29 of <span class="citation">Diggle, Liang, and
Zeger (1994)</span> for general correlation matrices, <span class="math inline">\(R\)</span>, is wrong).</p>
<p>The formula for linear models provided by <span class="citation">Liu
and Liang (1997)</span> is useful for testing <span class="math inline">\(H_0: \mathbf{\psi=0}\)</span> for any linear model
of the form: <span class="math display">\[
Y_{ij} = \mathbf{x}_{ij}&#39;\mathbf{\psi} +
\mathbf{z}_{ij}&#39;\mathbf{\lambda} + \varepsilon_{ij}
\]</span> where <span class="math inline">\(\mathbf{\varepsilon_i}\sim
N(\mathbf{0},\sigma^2R)\)</span> and the covariates for individual <span class="math inline">\(i\)</span>, <span class="math inline">\(\mathbf{x}_{i}=(\mathbf{x}_{i1}&#39;, \ldots,
\mathbf{x}_{i1}&#39;)&#39;_{n\times p}\)</span> and <span class="math inline">\(\mathbf{z}_{i}=(\mathbf{z}_{i1}&#39;, \ldots,
\mathbf{z}_{i1}&#39;)&#39;_{n\times q}\)</span>, arise from a known
discrete distribution. For our placebo controlled longitudinal study,
the fully specified model is of the form: <span class="math display">\[
Y_{ij}=\beta_0 + \beta_1\{{\rm Group}_{i}=A\} + \beta_2t_{ij} +
\beta_3t_{ij}\{{\rm Group}_{i}=A\}.
\]</span> That is, the parameter of interest for the interaction of
treatment and time is <span class="math inline">\(\psi =
\beta_3\)</span> and nuisance parameter is <span class="math inline">\(\mathbf{\lambda} =
(\beta_0,\beta_1,\beta_2)&#39;\)</span>. The covariates are distributed
as <span class="math inline">\(\mathbf{x}_{i} = \mathbf{t}= (t_1,
\ldots, t_n)&#39;\)</span> and <span class="math inline">\(\mathbf{z}_j
= [\mathbf{1}\, \mathbf{1}\, \mathbf{t}]_{n\times3}\)</span> with
probability 1/2 (Group A); and <span class="math inline">\(\mathbf{x}_{i} = \mathbf{0}\)</span> and <span class="math inline">\(\mathbf{z}_j = [\mathbf{1}\, \mathbf{0}\,
\mathbf{t}]_{n\times3}\)</span> with probability 1/2 (Group B).</p>
<p>The Liu and Liang’s formula for linear models can be coded In R
as:</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb1-1"><a href="#cb1-1" tabindex="-1"></a><span class="fu">library</span>(longpower)</span></code></pre></div>
<div class="sourceCode" id="cb2"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb2-1"><a href="#cb2-1" tabindex="-1"></a>liu.liang.linear.power</span></code></pre></div>
<pre><code>function (N = NULL, delta = NULL, u = NULL, v = NULL, sigma2 = 1, 
    R = NULL, R.list = NULL, sig.level = 0.05, power = NULL, 
    Pi = rep(1/length(u), length(u)), alternative = c(&quot;two.sided&quot;, 
        &quot;one.sided&quot;), tol = .Machine$double.eps^2) 
{
    if (sum(sapply(list(N, delta, sigma2, power, sig.level), 
        is.null)) != 1) 
        stop(&quot;exactly one of &#39;N&#39;, &#39;sigma2&#39;, &#39;delta&#39;, &#39;power&#39;, and &#39;sig.level&#39; must be NULL&quot;)
    if (!is.null(sig.level) &amp;&amp; !is.numeric(sig.level) || any(0 &gt; 
        sig.level | sig.level &gt; 1)) 
        stop(&quot;&#39;sig.level&#39; must be numeric in [0, 1]&quot;)
    alternative &lt;- match.arg(alternative)
    if (sum(c(!is.null(R), !is.null(R.list))) != 1) 
        stop(&quot;Exactly one of R or R.list must be specified.&quot;)
    if (sum(Pi) != 1) 
        stop(&quot;Pi must sum to 1.&quot;)
    if (!is.null(R)) {
        R.list &lt;- lapply(1:length(u), function(i) R)
    }
    Rinv &lt;- lapply(1:length(R.list), function(i) {
        R &lt;- R.list[[i]]
        if (is.null(dim(R)) &amp; length(R) == 1 &amp; length(u[[i]]) &gt; 
            1) {
            R &lt;- matrix(R, length(u[[i]]), length(u[[i]])) + 
                diag(1 - R, length(u[[i]]))
        }
        else if (is.null(dim(R)) &amp; length(R) == 1 &amp; length(u[[i]]) == 
            1) {
            R &lt;- matrix(R, length(u[[i]]), length(u[[i]]))
        }
        return(solve(R))
    })
    n.body &lt;- quote({
        Ipl &lt;- 0
        for (i in 1:length(u)) Ipl &lt;- Ipl + Pi[i] * t(u[[i]]) %*% 
            Rinv[[i]] %*% v[[i]]
        Ipl &lt;- Ipl/sigma2
        Ill &lt;- 0
        for (i in 1:length(u)) Ill &lt;- Ill + Pi[i] * t(v[[i]]) %*% 
            Rinv[[i]] %*% v[[i]]
        Illinv &lt;- solve(Ill/sigma2)
        Sigma1 &lt;- 0
        for (i in 1:length(u)) Sigma1 &lt;- Sigma1 + Pi[i] * (t(u[[i]]) - 
            Ipl %*% Illinv %*% t(v[[i]])) %*% Rinv[[i]] %*% (u[[i]] - 
            v[[i]] %*% Illinv %*% t(Ipl))
        Sigma1 &lt;- Sigma1/sigma2
        (qnorm(1 - ifelse(alternative == &quot;two.sided&quot;, sig.level/2, 
            sig.level)) + qnorm(power))^2/(delta %*% Sigma1 %*% 
            delta)[1, 1]
    })
    if (is.null(N)) 
        N &lt;- eval(n.body)
    else if (is.null(sig.level)) 
        sig.level &lt;- uniroot(function(sig.level) eval(n.body) - 
            N, c(1e-10, 1 - 1e-10), tol = tol, extendInt = &quot;yes&quot;)$root
    else if (is.null(power)) 
        power &lt;- uniroot(function(power) eval(n.body) - N, c(0.001, 
            1 - 1e-10), tol = tol, extendInt = &quot;yes&quot;)$root
    else if (is.null(delta)) 
        delta &lt;- uniroot(function(delta) eval(n.body) - N, sqrt(sigma2) * 
            c(1e-07, 1e+07), tol = tol, extendInt = &quot;downX&quot;)$root
    else if (is.null(sigma2)) 
        sigma2 &lt;- uniroot(function(sigma2) eval(n.body) - N, 
            delta * c(1e-07, 1e+07), tol = tol, extendInt = &quot;yes&quot;)$root
    else stop(&quot;internal error&quot;, domain = NA)
    METHOD &lt;- &quot;Longitudinal linear model power calculation (Liu &amp; Liang, 1997)&quot;
    structure(list(N = N, n = N * Pi, delta = delta, sigma2 = sigma2, 
        sig.level = sig.level, power = power, alternative = alternative, 
        R = R, note = &quot;N is *total* sample size and n is sample size in *each* group&quot;, 
        method = METHOD), class = &quot;power.longtest&quot;)
}
&lt;bytecode: 0x1115d84a0&gt;
&lt;environment: namespace:longpower&gt;</code></pre>
<p>The parameters include <code>d</code>, the effect size (possibly
vector); <code>u</code>, the list of covariate vectors or matrices
associated with the parameter of interest; <code>v</code>, the
respective list of covariate vectors or matrices associated with the
nuisance parameter; <code>sigma2</code>, the error variance;
<code>R</code>, the correlation structure; and <code>Pi</code> the
proportion of covariates of each type (<code>u</code>, <code>v</code>,
and <code>Pi</code> are expected to be the same length and sorted with
respect to each other).</p>
<p>For example, we can reproduce the table of sample sizes (per group)
on page 29 of <span class="citation">Diggle, Liang, and Zeger
(1994)</span> for the given exchangeable correlations with <span class="math inline">\(\mathbf{t} = (0,2,5)&#39;\)</span>, <span class="math inline">\(\alpha=0.05\)</span>, power=0.80, and <span class="math inline">\(d=0.5\)</span> via the
<code>diggle.linear.power()</code> function:</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb4-1"><a href="#cb4-1" tabindex="-1"></a>n <span class="ot">=</span> <span class="dv">3</span> <span class="co"># visits</span></span>
<span id="cb4-2"><a href="#cb4-2" tabindex="-1"></a>t <span class="ot">=</span> <span class="fu">c</span>(<span class="dv">0</span>,<span class="dv">2</span>,<span class="dv">5</span>)</span>
<span id="cb4-3"><a href="#cb4-3" tabindex="-1"></a>rho <span class="ot">=</span> <span class="fu">c</span>(<span class="fl">0.2</span>, <span class="fl">0.5</span>, <span class="fl">0.8</span>)</span>
<span id="cb4-4"><a href="#cb4-4" tabindex="-1"></a>sigma2 <span class="ot">=</span> <span class="fu">c</span>(<span class="dv">100</span>, <span class="dv">200</span>, <span class="dv">300</span>)</span>
<span id="cb4-5"><a href="#cb4-5" tabindex="-1"></a>tab.diggle <span class="ot">=</span> <span class="fu">outer</span>(rho, sigma2, </span>
<span id="cb4-6"><a href="#cb4-6" tabindex="-1"></a>      <span class="fu">Vectorize</span>(<span class="cf">function</span>(rho, sigma2){</span>
<span id="cb4-7"><a href="#cb4-7" tabindex="-1"></a>        <span class="fu">ceiling</span>(<span class="fu">diggle.linear.power</span>(</span>
<span id="cb4-8"><a href="#cb4-8" tabindex="-1"></a>          <span class="at">d=</span><span class="fl">0.5</span>,</span>
<span id="cb4-9"><a href="#cb4-9" tabindex="-1"></a>          <span class="at">t=</span>t,</span>
<span id="cb4-10"><a href="#cb4-10" tabindex="-1"></a>          <span class="at">sigma2=</span>sigma2,</span>
<span id="cb4-11"><a href="#cb4-11" tabindex="-1"></a>          <span class="at">R=</span>rho,</span>
<span id="cb4-12"><a href="#cb4-12" tabindex="-1"></a>          <span class="at">alternative=</span><span class="st">&quot;one.sided&quot;</span>,</span>
<span id="cb4-13"><a href="#cb4-13" tabindex="-1"></a>          <span class="at">power=</span><span class="fl">0.80</span>)<span class="sc">$</span>n[<span class="dv">1</span>])}))</span>
<span id="cb4-14"><a href="#cb4-14" tabindex="-1"></a><span class="fu">colnames</span>(tab.diggle) <span class="ot">=</span> <span class="fu">paste</span>(<span class="st">&quot;sigma2 =&quot;</span>, sigma2)</span>
<span id="cb4-15"><a href="#cb4-15" tabindex="-1"></a><span class="fu">rownames</span>(tab.diggle) <span class="ot">=</span> <span class="fu">paste</span>(<span class="st">&quot;rho =&quot;</span>, rho)</span>
<span id="cb4-16"><a href="#cb4-16" tabindex="-1"></a>tab.diggle</span></code></pre></div>
<pre><code>          sigma2 = 100 sigma2 = 200 sigma2 = 300
rho = 0.2          313          625          938
rho = 0.5          196          391          586
rho = 0.8           79          157          235</code></pre>
<p>or via the <code>liu.liang.linear.power()</code> function:</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb6-1"><a href="#cb6-1" tabindex="-1"></a>u <span class="ot">&lt;-</span> <span class="fu">list</span>(<span class="at">u1 =</span> t, <span class="at">u2 =</span> <span class="fu">rep</span>(<span class="dv">0</span>,n))</span>
<span id="cb6-2"><a href="#cb6-2" tabindex="-1"></a>v <span class="ot">&lt;-</span> <span class="fu">list</span>(<span class="at">v1 =</span> <span class="fu">cbind</span>(<span class="dv">1</span>,<span class="dv">1</span>,t),</span>
<span id="cb6-3"><a href="#cb6-3" tabindex="-1"></a>         <span class="at">v2 =</span> <span class="fu">cbind</span>(<span class="dv">1</span>,<span class="dv">0</span>,t))         </span>
<span id="cb6-4"><a href="#cb6-4" tabindex="-1"></a>tab.ll <span class="ot">&lt;-</span> <span class="fu">outer</span>(rho, sigma2, </span>
<span id="cb6-5"><a href="#cb6-5" tabindex="-1"></a>      <span class="fu">Vectorize</span>(<span class="cf">function</span>(rho, sigma2){</span>
<span id="cb6-6"><a href="#cb6-6" tabindex="-1"></a>        <span class="fu">ceiling</span>(<span class="fu">liu.liang.linear.power</span>(</span>
<span id="cb6-7"><a href="#cb6-7" tabindex="-1"></a>          <span class="at">delta=</span><span class="fl">0.5</span>, <span class="at">u=</span>u, <span class="at">v=</span>v,</span>
<span id="cb6-8"><a href="#cb6-8" tabindex="-1"></a>          <span class="at">sigma2=</span>sigma2,</span>
<span id="cb6-9"><a href="#cb6-9" tabindex="-1"></a>          <span class="at">R=</span>rho, <span class="at">alternative=</span><span class="st">&quot;one.sided&quot;</span>,</span>
<span id="cb6-10"><a href="#cb6-10" tabindex="-1"></a>          <span class="at">power=</span><span class="fl">0.80</span>)<span class="sc">$</span>n[<span class="dv">1</span>])}))</span>
<span id="cb6-11"><a href="#cb6-11" tabindex="-1"></a><span class="fu">colnames</span>(tab.ll) <span class="ot">&lt;-</span> <span class="fu">paste</span>(<span class="st">&quot;sigma2 =&quot;</span>, sigma2)</span>
<span id="cb6-12"><a href="#cb6-12" tabindex="-1"></a><span class="fu">rownames</span>(tab.ll) <span class="ot">&lt;-</span> <span class="fu">paste</span>(<span class="st">&quot;rho =&quot;</span>, rho)</span>
<span id="cb6-13"><a href="#cb6-13" tabindex="-1"></a>tab.ll</span></code></pre></div>
<pre><code>          sigma2 = 100 sigma2 = 200 sigma2 = 300
rho = 0.2          313          625          938
rho = 0.5          196          391          586
rho = 0.8           79          157          235</code></pre>
<p>As a second example, consider an Alzheimer’s disease trial in which
assessments are taken every three months for 18 months (7 visits). We
assume an smallest detectable effect size of 1.5 points on the cognitive
portion of the Alzheimer’s Disease Assessment Scale (ADAS-Cog). This is
a 70 point scale with great variability among sick individuals. We
assume the random intercept to have a variance of 55, the random slope
to have a variance of 24, and a residual variance of 10. The correlation
between random slope term and random intercept term is 0.8. We can
estimate the necessary sample size by first generating the correlation
structure. Since <span class="math inline">\(\varepsilon =
\mathrm{var}(Y_{ij})\)</span> is not constant over time in this model,
we fix <code>sigma2=1</code> and set <code>R</code> equal to the
covariance matrix for <span class="math inline">\(\mathbf{\varepsilon_i}\)</span>:</p>
<div class="sourceCode" id="cb8"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb8-1"><a href="#cb8-1" tabindex="-1"></a><span class="co"># var of random intercept</span></span>
<span id="cb8-2"><a href="#cb8-2" tabindex="-1"></a>sig2.i <span class="ot">&lt;-</span> <span class="dv">55</span></span>
<span id="cb8-3"><a href="#cb8-3" tabindex="-1"></a><span class="co"># var of random slope</span></span>
<span id="cb8-4"><a href="#cb8-4" tabindex="-1"></a>sig2.s <span class="ot">&lt;-</span> <span class="dv">24</span></span>
<span id="cb8-5"><a href="#cb8-5" tabindex="-1"></a><span class="co"># residual var</span></span>
<span id="cb8-6"><a href="#cb8-6" tabindex="-1"></a>sig2.e <span class="ot">&lt;-</span> <span class="dv">10</span></span>
<span id="cb8-7"><a href="#cb8-7" tabindex="-1"></a><span class="co"># covariance of slope and intercep</span></span>
<span id="cb8-8"><a href="#cb8-8" tabindex="-1"></a>cov.s.i <span class="ot">&lt;-</span> <span class="fl">0.8</span><span class="sc">*</span><span class="fu">sqrt</span>(sig2.i)<span class="sc">*</span><span class="fu">sqrt</span>(sig2.s)</span>
<span id="cb8-9"><a href="#cb8-9" tabindex="-1"></a></span>
<span id="cb8-10"><a href="#cb8-10" tabindex="-1"></a>cov.t <span class="ot">&lt;-</span> <span class="cf">function</span>(t1, t2, sig2.i, sig2.s, cov.s.i){</span>
<span id="cb8-11"><a href="#cb8-11" tabindex="-1"></a>        sig2.i <span class="sc">+</span> t1<span class="sc">*</span>t2<span class="sc">*</span>sig2.s <span class="sc">+</span> (t1<span class="sc">+</span>t2)<span class="sc">*</span>cov.s.i </span>
<span id="cb8-12"><a href="#cb8-12" tabindex="-1"></a>}</span>
<span id="cb8-13"><a href="#cb8-13" tabindex="-1"></a></span>
<span id="cb8-14"><a href="#cb8-14" tabindex="-1"></a>t <span class="ot">&lt;-</span> <span class="fu">seq</span>(<span class="dv">0</span>,<span class="fl">1.5</span>,<span class="fl">0.25</span>)</span>
<span id="cb8-15"><a href="#cb8-15" tabindex="-1"></a>n <span class="ot">&lt;-</span> <span class="fu">length</span>(t)</span>
<span id="cb8-16"><a href="#cb8-16" tabindex="-1"></a>R <span class="ot">&lt;-</span> <span class="fu">outer</span>(t, t, <span class="cf">function</span>(x,y){<span class="fu">cov.t</span>(x,y, sig2.i, sig2.s, cov.s.i)})</span>
<span id="cb8-17"><a href="#cb8-17" tabindex="-1"></a>R <span class="ot">&lt;-</span> R <span class="sc">+</span> <span class="fu">diag</span>(sig2.e, n, n)</span>
<span id="cb8-18"><a href="#cb8-18" tabindex="-1"></a>u <span class="ot">&lt;-</span> <span class="fu">list</span>(<span class="at">u1 =</span> t, <span class="at">u2 =</span> <span class="fu">rep</span>(<span class="dv">0</span>,n))</span>
<span id="cb8-19"><a href="#cb8-19" tabindex="-1"></a>v <span class="ot">&lt;-</span> <span class="fu">list</span>(<span class="at">v1 =</span> <span class="fu">cbind</span>(<span class="dv">1</span>,<span class="dv">1</span>,t),</span>
<span id="cb8-20"><a href="#cb8-20" tabindex="-1"></a>         <span class="at">v2 =</span> <span class="fu">cbind</span>(<span class="dv">1</span>,<span class="dv">0</span>,t))         </span>
<span id="cb8-21"><a href="#cb8-21" tabindex="-1"></a></span>
<span id="cb8-22"><a href="#cb8-22" tabindex="-1"></a><span class="fu">liu.liang.linear.power</span>(<span class="at">d=</span><span class="fl">1.5</span>, <span class="at">u=</span>u, <span class="at">v=</span>v, <span class="at">R=</span>R, <span class="at">sig.level=</span><span class="fl">0.05</span>, <span class="at">power=</span><span class="fl">0.80</span>)</span></code></pre></div>
<pre><code>
     Longitudinal linear model power calculation (Liu &amp; Liang, 1997) 

              N = 414.6202
              n = 207.3101, 207.3101
          delta = 1.5
         sigma2 = 1
      sig.level = 0.05
          power = 0.8
    alternative = two.sided

 NOTE: N is *total* sample size and n is sample size in *each* group 

 R:
         [,1]      [,2]      [,3]      [,4]      [,5]     [,6]      [,7]
[1,] 65.00000  62.26636  69.53272  76.79908  84.06544  91.3318  98.59817
[2,] 62.26636  81.03272  79.79908  88.56544  97.33180 106.0982 114.86453
[3,] 69.53272  79.79908 100.06544 100.33180 110.59817 120.8645 131.13089
[4,] 76.79908  88.56544 100.33180 122.09817 123.86453 135.6309 147.39725
[5,] 84.06544  97.33180 110.59817 123.86453 147.13089 150.3972 163.66361
[6,] 91.33180 106.09817 120.86453 135.63089 150.39725 175.1636 179.92997
[7,] 98.59817 114.86453 131.13089 147.39725 163.66361 179.9300 206.19633</code></pre>
<p>So the study would require about 207 subjects per arm to achieve 80%
power, with a two-tailed <span class="math inline">\(\alpha=0.05\)</span>.</p>
<p>The simple formula provided in <span class="citation">Diggle, Liang,
and Zeger (1994)</span> suggests the required number of subjects can be
found by <span class="math inline">\(2(z_\alpha+z_Q)^2\xi/d^2\)</span>,
where <span class="math display">\[
\xi_\textrm{WRONG}=
  \left(\begin{array}{cc}
    0 &amp; 1\\
    \end{array}\right)
\left(\begin{array}{ccc}
1 &amp; \ldots &amp; 1 \\
t_1 &amp; \ldots &amp; t_n \\
\end{array}\right)R^{-1}
\left(\begin{array}{ccc}
1 &amp; t_1 \\
\vdots &amp; \vdots\\
1 &amp; t_n
\end{array}\right)
  \left(\begin{array}{c}
    0 \\ 1
    \end{array}\right).
\]</span> Executing this for our Alzheimer’s example, we get a sample
size of:</p>
<div class="sourceCode" id="cb10"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb10-1"><a href="#cb10-1" tabindex="-1"></a>x <span class="ot">&lt;-</span> (<span class="fu">rbind</span>(<span class="dv">1</span>,t)<span class="sc">%*%</span><span class="fu">solve</span>(R)<span class="sc">%*%</span><span class="fu">cbind</span>(<span class="dv">1</span>,t))[<span class="dv">2</span>,<span class="dv">2</span>]</span>
<span id="cb10-2"><a href="#cb10-2" tabindex="-1"></a>x<span class="sc">*</span><span class="dv">2</span><span class="sc">*</span>(<span class="fu">qnorm</span>(<span class="dv">1</span><span class="fl">-0.05</span><span class="sc">/</span><span class="dv">2</span>) <span class="sc">+</span> <span class="fu">qnorm</span>(<span class="fl">0.80</span>))<span class="sc">^</span><span class="dv">2</span><span class="sc">/</span><span class="fl">1.5</span><span class="sc">^</span><span class="dv">2</span></span></code></pre></div>
<pre><code>[1] 0.3592744</code></pre>
<p>which is clearly wrong. In fact, there is a typo in <span class="citation">Diggle, Liang, and Zeger (1994)</span>. The correct
formula for <span class="math inline">\(\xi\)</span> is: <span class="math display">\[\begin{equation}\label{eq:diggle3}
\xi =
  \left(\begin{array}{cc}
    0 &amp; 1\\
    \end{array}\right)
  \left[
  \left(\begin{array}{ccc}
    1 &amp; \cdots &amp; 1 \\
    t_1 &amp; \cdots &amp; t_2\end{array}\right)
  (\sigma^2R)^{-1}
  \left(\begin{array}{cc}
    1 &amp; t_1 \\
    \vdots &amp; \vdots \\
    1 &amp; t_m\end{array}\right)\right]^{-1}
  \left(\begin{array}{c}
    0 \\ 1
    \end{array}\right).
\end{equation}\]</span></p>
<p>Applying the correct formula, we get</p>
<div class="sourceCode" id="cb12"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb12-1"><a href="#cb12-1" tabindex="-1"></a>x <span class="ot">&lt;-</span> <span class="fu">solve</span>(<span class="fu">rbind</span>(<span class="dv">1</span>,t)<span class="sc">%*%</span><span class="fu">solve</span>(R)<span class="sc">%*%</span><span class="fu">cbind</span>(<span class="dv">1</span>,t))[<span class="dv">2</span>,<span class="dv">2</span>]</span>
<span id="cb12-2"><a href="#cb12-2" tabindex="-1"></a>x<span class="sc">*</span><span class="dv">2</span><span class="sc">*</span>(<span class="fu">qnorm</span>(<span class="dv">1</span><span class="fl">-0.05</span><span class="sc">/</span><span class="dv">2</span>) <span class="sc">+</span> <span class="fu">qnorm</span>(<span class="fl">0.80</span>))<span class="sc">^</span><span class="dv">2</span><span class="sc">/</span><span class="fl">1.5</span><span class="sc">^</span><span class="dv">2</span></span></code></pre></div>
<pre><code>[1] 207.3101</code></pre>
<p>Similarly, using <span class="citation">Liu and Liang (1997)</span>,
we attempt to derive the correct closed form formula for this specific
linear model. The required sample size per group is given as <span class="math display">\[
m = \nu/(\psi_1&#39;\tilde\Sigma_1\psi_1)
\]</span> where <span class="math display">\[
\tilde\Sigma_1 =\sigma^{-2}\sum_{l=1}^m\pi_l
(\mathbf{u}_l&#39;-I_{\psi\lambda}I_{\lambda\lambda}^-1\mathbf{v}_l&#39;)R^{-1}
(\mathbf{u}_l&#39;-\mathbf{v}_lI_{\lambda\lambda}^-1I_{\psi\lambda}&#39;),
\]</span> <span class="math display">\[
I_{\psi\lambda}=\sigma^{-2}\sum_{i=1}^m\pi_l
\mathbf{u}_l&#39;R^{-1}\mathbf{v}_l,
\]</span> and <span class="math display">\[
I_{\lambda\lambda}=\sigma^{-2}\sum_{i=1}^m\pi_l
\mathbf{v}_l&#39;R^{-1}\mathbf{v}_l.
\]</span> Again, in our case the probability of each of the two
covariate values is <span class="math inline">\(\pi_1=\pi_2=1/2\)</span>; and <span class="math inline">\(\mathbf{u}_1 = (t_1, \ldots, t_n)&#39;\)</span>,
<span class="math inline">\(\mathbf{v}_1 = [\mathbf{1}\, \mathbf{0}\,
\mathbf{x}_i]_{n\times3}\)</span>, <span class="math inline">\(\mathbf{u}_2 = \mathbf{0}\)</span>, and <span class="math inline">\(\mathbf{v}_2 = [\mathbf{1}\, \mathbf{0}\,
\mathbf{x}_i]_{n\times3}\)</span>. We have</p>
<p><span class="math display">\[\begin{eqnarray*}
I_{\psi\lambda}&amp; = &amp;
\sigma^{-2}/2\mathbf{u}_1&#39;R^{-1}\mathbf{v}_1\\
I_{\lambda\lambda}&amp; = &amp;
\sigma^{-2}/2[\mathbf{v}_1&#39;R^{-1}\mathbf{v}_1 +
\mathbf{v}_2&#39;R^{-1}\mathbf{v}_2]=1/2X]\\
I_{\psi\lambda}I_{\lambda\lambda}^{-1} &amp; = &amp;
\mathbf{u}_1&#39;R^{-1}\mathbf{v}_1X^{-1}\\
I_{\lambda\lambda}^{-1}I_{\psi\lambda}&#39; &amp; = &amp;
X^{-1}\mathbf{v}_1&#39;R^{-1}\mathbf{u}_1
\end{eqnarray*}\]</span></p>
<p><span class="math display">\[\begin{eqnarray*}
\tilde\Sigma_1 &amp; = &amp; \sigma^{-2}/2
[(\mathbf{u}_1-\mathbf{u}_1&#39;R^{-1}\mathbf{v}_1X^{-1}\mathbf{v}_1&#39;)
R^{-1}
(\mathbf{u}_1-\mathbf{v}_1X^{-1}\mathbf{v}_1&#39;R^{-1}\mathbf{u}_1)\\
&amp; &amp;
+  \mathbf{u}_1&#39;R^{-1}\mathbf{v}_1X^{-1}\mathbf{v}_2&#39;R^{-1}\mathbf{v}_2X^{-1}\mathbf{v}_1R^{-1}\mathbf{u}_1\\
&amp; = &amp;
\sigma^{-2}/2[\mathbf{u}_1R^{-1}\mathbf{u}-
\mathbf{u}_1&#39;R^{-1}\mathbf{v}_1X^{-1}\mathbf{v}_1&#39;R^{-1}\mathbf{u}_1]
\end{eqnarray*}\]</span> Applying this to our working example:</p>
<div class="sourceCode" id="cb14"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb14-1"><a href="#cb14-1" tabindex="-1"></a>X <span class="ot">&lt;-</span> <span class="fu">t</span>(v[[<span class="dv">1</span>]])<span class="sc">%*%</span><span class="fu">solve</span>(R)<span class="sc">%*%</span>v[[<span class="dv">1</span>]] <span class="sc">+</span> </span>
<span id="cb14-2"><a href="#cb14-2" tabindex="-1"></a>    <span class="fu">t</span>(v[[<span class="dv">2</span>]])<span class="sc">%*%</span><span class="fu">solve</span>(R)<span class="sc">%*%</span>v[[<span class="dv">2</span>]]</span>
<span id="cb14-3"><a href="#cb14-3" tabindex="-1"></a></span>
<span id="cb14-4"><a href="#cb14-4" tabindex="-1"></a>Sigma1 <span class="ot">&lt;-</span> ((<span class="fu">t</span>(u[[<span class="dv">1</span>]])<span class="sc">%*%</span><span class="fu">solve</span>(R)<span class="sc">%*%</span>t <span class="sc">-</span> </span>
<span id="cb14-5"><a href="#cb14-5" tabindex="-1"></a>           <span class="fu">t</span>(u[[<span class="dv">1</span>]])<span class="sc">%*%</span><span class="fu">solve</span>(R)<span class="sc">%*%</span>v[[<span class="dv">1</span>]]<span class="sc">%*%</span><span class="fu">solve</span>(X)<span class="sc">%*%</span><span class="fu">t</span>(v[[<span class="dv">1</span>]])<span class="sc">%*%</span><span class="fu">solve</span>(R)<span class="sc">%*%</span>t)<span class="sc">/</span><span class="dv">2</span>)</span>
<span id="cb14-6"><a href="#cb14-6" tabindex="-1"></a></span>
<span id="cb14-7"><a href="#cb14-7" tabindex="-1"></a>(<span class="fu">qnorm</span>(<span class="dv">1</span><span class="fl">-0.05</span><span class="sc">/</span><span class="dv">2</span>) <span class="sc">+</span> <span class="fu">qnorm</span>(<span class="fl">0.80</span>))<span class="sc">^</span><span class="dv">2</span><span class="sc">/</span>(Sigma1<span class="sc">*</span>(<span class="fl">1.5</span>)<span class="sc">^</span><span class="dv">2</span>)<span class="sc">/</span><span class="dv">2</span></span></code></pre></div>
<pre><code>         [,1]
[1,] 207.3101</code></pre>
<!-- ## Example: Ophthalmology -->
<!-- Suppose we are planning a study to test the reproducibility of a non-invasive diagnostic imaging tool, spectral domain optical coherence tomography (OCT), for children with retinal pathology. OCT produces a measure of cortical thickness in the left and right eye. We consider modeling the linear association the cortical thickness as measured by the first OCT, $X$, and the second $Y$, as: -->
<!-- \[ -->
<!-- Y_{ij} = \beta_0 + \beta_1X_{ij} + \alpha_{i} + \epsilon_{ij}^* -->
<!-- \] -->
<!-- for individual $i=1,\ldots,N$, and eye $j=1,2$. The parameter of interest is $\psi=\beta_1$ and the nuisance parameter is $\beta_0$. The covariates are distributed as $\x_{i}=(1,1)'$, and $\mathbf{z}_{i}=(z_1,z_2)\sim N(\mathbf{0},\Sigma)$ -->
<!-- ```{r echo=TRUE} -->
<!-- n=2 -->
<!-- B=10000 -->
<!-- rho = 0.5 -->
<!-- Sigma = matrix(c(1,rho,rho,1),nrow=2) # variance/covariance matrix for left/right obs -->
<!-- u = v = vector("list",B) -->
<!-- for(i in 1:B) u[[i]] = rep(1,2) -->
<!-- vv = rmvnorm(B, sigma = Sigma) -->
<!-- for(i in 1:B) v[[i]] = vv[i,] -->
<!-- liu.liang.linear.power(d=0.1, u=u, v=v, R=Sigma, sig.level=0.05/2) -->
<!-- liu.liang.linear.power(d=0.25, u=u, v=v, R=Sigma, sig.level=0.05/2) -->
<!-- liu.liang.linear.power(d=0.5, u=u, v=v, R=Sigma, sig.level=0.05/2) -->
<!-- liu.liang.linear.power(d=0.75, u=u, v=v, R=Sigma, sig.level=0.05/2) -->
<!-- ``` -->
<!-- Simulated power: -->
<!-- ```{r echo=FALSE} -->
<!-- library(nlme) -->
<!-- B=10000 -->
<!-- n = 20 -->
<!-- sim = rep(0,B) -->
<!-- d = 0.5 -->
<!-- for(i in 1:B){ -->
<!-- X = rmvnorm(n, sigma = Sigma) -->
<!-- e = rmvnorm(n, sigma = Sigma) -->
<!-- X = as.vector(t(X)) -->
<!-- e = as.vector(t(e)) -->
<!-- cluster = rep(1:n,rep(2,n)) -->
<!-- Y = d*X + e -->
<!-- if(summary(lme(Y~X, random = ~ 1 | cluster))$tTable["X","p-value"]<0.05) sim[i]=1 -->
<!-- } -->
<!-- sum(sim)/B -->
<!-- ``` -->
</div>
</div>
<div id="references" class="section level1 unnumbered">
<h1 class="unnumbered">References</h1>
<div id="refs" class="references csl-bib-body hanging-indent">
<div id="ref-diggle" class="csl-entry">
Diggle, Peter, Kung-Yee Liang, and Scott L. Zeger. 1994. <em>Analysis of
Longitudinal Data</em>. Oxford; New York: Clarendon Press ; Oxford
University Press.
</div>
<div id="ref-laird" class="csl-entry">
Laird, N. M., and J. H. Ware. 1982. <span>“Random-Effects Models for
Longitudinal Data.”</span> <em>Biometrics</em> 38 (4): 963–74.
</div>
<div id="ref-liu" class="csl-entry">
Liu, G., and K. Y. Liang. 1997. <span>“Sample Size Calculations for
Studies with Correlated Observations.”</span> <em>Biometrics</em> 53
(3): 937–47.
</div>
<div id="ref-zeger" class="csl-entry">
Zeger, S. L., and K. Y. Liang. 1986. <span>“Longitudinal Data Analysis
for Discrete and Continuous Outcomes.”</span> <em>Biometrics</em> 42
(1): 121–30.
</div>
</div>
</div>



<!-- code folding -->


<!-- dynamically load mathjax for compatibility with self-contained -->
<script>
  (function () {
    var script = document.createElement("script");
    script.type = "text/javascript";
    script.src  = "https://mathjax.rstudio.com/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML";
    document.getElementsByTagName("head")[0].appendChild(script);
  })();
</script>

</body>
</html>
